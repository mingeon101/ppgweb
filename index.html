<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>안정화 심박수 측정</title>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; padding: 20px; }
    video { display: none; }
    canvas { border: 1px solid #ccc; margin-top: 10px; }
    #bpm { font-size: 24px; margin-top: 10px; font-weight: bold; }
    #avgBpm { font-size: 20px; margin-top: 5px; color: blue; }
    #status { font-size: 16px; margin-top: 5px; color: gray; }
  </style>
</head>
<body>
  <h2>📸 자동 플래시 심박수 측정 (안정화 버전)</h2>
  <p>📌 손가락을 렌즈 위에 올리면 자동으로 심박수 측정</p>
  <video id="video" autoplay playsinline></video>
  <canvas id="graph" width="400" height="150"></canvas>
  <p id="bpm">심박수: ---</p>
  <p id="avgBpm">평균 BPM: ---</p>
  <p id="status">카메라 준비 중...</p>

  <script>
    const video = document.getElementById("video");
    const canvasGraph = document.getElementById("graph");
    const gctx = canvasGraph.getContext("2d");
    const bpmText = document.getElementById("bpm");
    const avgBpmText = document.getElementById("avgBpm");
    const statusText = document.getElementById("status");

    const buffer = [];
    const bpmBuffer = [];
    const timeWindow = 15000; // 최근 15초

    async function startCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal: "environment" }, width: { ideal: 640 }, height: { ideal: 480 } }
        });
        video.srcObject = stream;
        statusText.innerText = "카메라 준비 완료";

        // 플래시 켜기
        const track = stream.getVideoTracks()[0];
        const capabilities = track.getCapabilities();
        if(capabilities.torch){
          await track.applyConstraints({ advanced: [{ torch: true }] });
          statusText.innerText += " | 플래시 켜짐";
        } else {
          statusText.innerText += " | 플래시 지원 안 됨, 수동 켜기 필요";
        }
      } catch (err) {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ video: true });
          video.srcObject = stream;
          statusText.innerText = "후면 카메라 실패, 기본 카메라 사용";
        } catch (e) {
          statusText.innerText = "카메라 접근 실패: " + e.message;
        }
      }
    }
    startCamera();

    function movingAverage(data, windowSize=5) {
      return data.map((val,i,arr)=>{
        let start = Math.max(0,i-windowSize);
        let end = Math.min(arr.length,i+windowSize);
        let subset = arr.slice(start,end);
        return subset.reduce((a,b)=>a+b,0)/subset.length;
      });
    }

    function analyzeFrame() {
      if(video.readyState < 2){
        requestAnimationFrame(analyzeFrame);
        return;
      }

      const tempCanvas = document.createElement("canvas");
      tempCanvas.width = video.videoWidth;
      tempCanvas.height = video.videoHeight;
      const tctx = tempCanvas.getContext("2d");
      tctx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);
      const frame = tctx.getImageData(0,0,tempCanvas.width,tempCanvas.height).data;

      // R 채널 평균
      let sum = 0;
      for(let i=0;i<frame.length;i+=4) sum += frame[i];
      let redAvg = sum/(frame.length/4);
      buffer.push({t:Date.now(),v:redAvg});
      while(buffer.length && buffer[0].t < Date.now()-timeWindow) buffer.shift();

      if(buffer.length>20){
        let smoothed = movingAverage(buffer.map(d=>d.v),5);

        // 피크 검출
        let peaks = 0;
        for(let i=1;i<smoothed.length-1;i++){
          if(smoothed[i]>smoothed[i-1] && smoothed[i]>smoothed[i+1]) peaks++;
        }

        let duration = (buffer[buffer.length-1].t-buffer[0].t)/1000;
        let bpm = Math.round((peaks/duration)*60);
        if(bpm>40 && bpm<180) {
          bpmText.innerText = "심박수: "+bpm+" BPM";
          bpmBuffer.push(bpm);
          if(bpmBuffer.length>10) bpmBuffer.shift();
          const avgBpm = Math.round(bpmBuffer.reduce((a,b)=>a+b,0)/bpmBuffer.length);
          avgBpmText.innerText = "평균 BPM: "+avgBpm;
        }

        // 그래프
        gctx.clearRect(0,0,canvasGraph.width,canvasGraph.height);
        gctx.beginPath();
        smoothed.forEach((val,i)=>{
          let x = (i/smoothed.length)*canvasGraph.width;
          let y = canvasGraph.height - ((val-Math.min(...smoothed))/(Math.max(...smoothed)-Math.min(...smoothed)))*canvasGraph.height;
          if(i===0) gctx.moveTo(x,y); else gctx.lineTo(x,y);
        });
        gctx.strokeStyle="red";
        gctx.stroke();
      }

      requestAnimationFrame(analyzeFrame);
    }

    analyzeFrame();
  </script>
</body>
</html>
