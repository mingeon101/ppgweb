<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>ì•ˆì •ì ì¸ ì›¹ ì‹¬ë°•ìˆ˜ ì¸¡ì •</title>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; }
    video { display:none; }
    #bpm { font-size: 24px; margin-top: 10px; }
    canvas { border:1px solid #ccc; margin-top:10px; }
  </style>
</head>
<body>
  <h2>ğŸ“¸ í”Œë˜ì‹œ + ì¹´ë©”ë¼ ê¸°ë°˜ ì‹¬ë°•ìˆ˜ ì¸¡ì •</h2>
  <p>ğŸ“Œ ìŠ¤ë§ˆíŠ¸í° í›„ë©´ ì¹´ë©”ë¼ + í”Œë˜ì‹œ ì¼œê³  ì†ê°€ë½ì„ ì˜¬ë ¤ë‘ì„¸ìš”</p>
  <video id="video" autoplay playsinline></video>
  <canvas id="graph" width="400" height="150"></canvas>
  <p id="bpm">ì‹¬ë°•ìˆ˜: ---</p>

  <script>
    const video = document.getElementById("video");
    const canvasGraph = document.getElementById("graph");
    const gctx = canvasGraph.getContext("2d");
    const bpmText = document.getElementById("bpm");

    const buffer = [];
    const timeWindow = 10000; // ìµœê·¼ 10ì´ˆë§Œ ë³´ê´€

    navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
      .then(stream => video.srcObject = stream)
      .catch(err => alert("ì¹´ë©”ë¼ ì ‘ê·¼ ì‹¤íŒ¨: " + err));

    function movingAverage(data, windowSize=5) {
      return data.map((val, i, arr) => {
        let start = Math.max(0, i - windowSize);
        let end = Math.min(arr.length, i + windowSize);
        let subset = arr.slice(start, end);
        return subset.reduce((a, b) => a + b, 0) / subset.length;
      });
    }

    function analyzeFrame() {
      const tempCanvas = document.createElement("canvas");
      tempCanvas.width = video.videoWidth;
      tempCanvas.height = video.videoHeight;
      const tctx = tempCanvas.getContext("2d");
      tctx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);

      const frame = tctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height).data;

      // ğŸ”´ R ì±„ë„ í‰ê· 
      let sum = 0;
      for (let i = 0; i < frame.length; i += 4) {
        sum += frame[i]; // Rë§Œ ì‚¬ìš©
      }
      let redAvg = sum / (frame.length / 4);

      buffer.push({ t: Date.now(), v: redAvg });
      // ìµœê·¼ 10ì´ˆë§Œ ìœ ì§€
      while (buffer.length && buffer[0].t < Date.now() - timeWindow) buffer.shift();

      if (buffer.length > 20) {
        // smoothing
        let smoothed = movingAverage(buffer.map(d => d.v), 5);

        // í”¼í¬ ê²€ì¶œ
        let peaks = 0;
        for (let i = 1; i < smoothed.length - 1; i++) {
          if (smoothed[i] > smoothed[i-1] && smoothed[i] > smoothed[i+1]) peaks++;
        }

        let duration = (buffer[buffer.length-1].t - buffer[0].t) / 1000; // ì´ˆ
        let bpm = Math.round((peaks / duration) * 60);

        if (bpm > 40 && bpm < 180) {
          bpmText.innerText = "ì‹¬ë°•ìˆ˜: " + bpm + " BPM";
        }

        // ê·¸ë˜í”„ ê·¸ë¦¬ê¸°
        gctx.clearRect(0, 0, canvasGraph.width, canvasGraph.height);
        gctx.beginPath();
        smoothed.forEach((val, i) => {
          let x = (i / smoothed.length) * canvasGraph.width;
          let y = canvasGraph.height - ((val - Math.min(...smoothed)) / (Math.max(...smoothed) - Math.min(...smoothed))) * canvasGraph.height;
          if (i === 0) gctx.moveTo(x, y);
          else gctx.lineTo(x, y);
        });
        gctx.strokeStyle = "red";
        gctx.stroke();
      }

      requestAnimationFrame(analyzeFrame);
    }

    analyzeFrame();
  </script>
</body>
</html>
